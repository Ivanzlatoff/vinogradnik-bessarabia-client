{"ast":null,"code":"import axios from 'axios';\nimport { TOKEN } from './constants';\nimport jwt_decode from \"jwt-decode\";\nexport const BASE_URL = 'http://localhost:5000/api/';\nexport const publicRequest = axios.create({\n  baseURL: BASE_URL\n});\nexport const userRequest = axios.create({\n  baseURL: BASE_URL\n});\nexport const updateRefreshToken = (refreshToken, refreshTokenId) => {\n  localStorage.setItem(TOKEN, JSON.stringify({\n    refreshToken,\n    refreshTokenId\n  }));\n};\nexport const getRefreshToken = () => JSON.parse(localStorage.getItem(TOKEN) || '{}');\nexport const existRefreshToken = () => !!getRefreshToken().refreshToken;\nexport const clearRefreshToken = () => localStorage.removeItem(TOKEN);\nuserRequest.interceptors.request.use(async config => {\n  let existingAccessToken = !!config.headers.token;\n  console.log(existingAccessToken);\n  if (existRefreshToken) {\n    var _config$headers$token;\n    const accessToken = (_config$headers$token = config.headers.token) === null || _config$headers$token === void 0 ? void 0 : _config$headers$token.substring(7);\n    let currentDate = new Date();\n    const decodedToken = accessToken && jwt_decode(accessToken);\n    existingAccessToken = decodedToken && decodedToken.exp * 1000 < currentDate.getTime();\n  }\n  if (!existingAccessToken) {\n    const {\n      refreshToken,\n      refreshTokenId\n    } = getRefreshToken();\n    try {\n      const res = await publicRequest.put(\"/auth/refresh_token\", {\n        refreshToken,\n        refreshTokenId\n      });\n      updateRefreshToken(res.data.refreshToken, refreshTokenId);\n      config.headers[\"token\"] = \"Bearer \" + res.data.newAccessToken;\n    } catch (err) {\n      console.error(err);\n    }\n  }\n  return config;\n}, error => {\n  return Promise.reject(error);\n});","map":{"version":3,"names":["axios","TOKEN","jwt_decode","BASE_URL","publicRequest","create","baseURL","userRequest","updateRefreshToken","refreshToken","refreshTokenId","localStorage","setItem","JSON","stringify","getRefreshToken","parse","getItem","existRefreshToken","clearRefreshToken","removeItem","interceptors","request","use","config","existingAccessToken","headers","token","console","log","accessToken","substring","currentDate","Date","decodedToken","exp","getTime","res","put","data","newAccessToken","err","error","Promise","reject"],"sources":["D:/Work/vinogradnik/client/src/requestMethods.js"],"sourcesContent":["import axios from 'axios';\r\nimport { TOKEN } from './constants';\r\nimport jwt_decode from \"jwt-decode\";\r\n\r\nexport const BASE_URL = 'http://localhost:5000/api/';\r\n\r\nexport const publicRequest = axios.create({\r\n    baseURL: BASE_URL\r\n});\r\n\r\nexport const userRequest = axios.create({\r\n    baseURL: BASE_URL,\r\n});\r\n\r\nexport const updateRefreshToken = (refreshToken, refreshTokenId) => {\r\n    localStorage.setItem(TOKEN, JSON.stringify({\r\n        refreshToken,\r\n        refreshTokenId\r\n    }))\r\n};\r\n\r\nexport const getRefreshToken = () => JSON.parse(localStorage.getItem(TOKEN) || '{}');\r\n\r\nexport const existRefreshToken = () => !!getRefreshToken().refreshToken;\r\n\r\nexport const clearRefreshToken = () => localStorage.removeItem(TOKEN);\r\n\r\nuserRequest.interceptors.request.use(async (config) => {\r\n    let existingAccessToken = !!config.headers.token;\r\n    console.log(existingAccessToken)\r\n    if (existRefreshToken) {\r\n        const accessToken = config.headers.token?.substring(7);\r\n        let currentDate = new Date();\r\n        const decodedToken = accessToken && jwt_decode(accessToken);\r\n        existingAccessToken = decodedToken && decodedToken.exp * 1000 < currentDate.getTime();\r\n    }\r\n    if (!existingAccessToken) {\r\n        const { refreshToken, refreshTokenId } = getRefreshToken();\r\n        try {\r\n            const res = await publicRequest.put(\"/auth/refresh_token\", { refreshToken, refreshTokenId });\r\n            updateRefreshToken(res.data.refreshToken, refreshTokenId);\r\n            config.headers[\"token\"] = \"Bearer \" + res.data.newAccessToken;\r\n        } catch (err) {\r\n            console.error(err)\r\n        }\r\n    }\r\n    return config;\r\n}, (error) => {\r\n    return Promise.reject(error)\r\n});\r\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,KAAK,QAAQ,aAAa;AACnC,OAAOC,UAAU,MAAM,YAAY;AAEnC,OAAO,MAAMC,QAAQ,GAAG,4BAA4B;AAEpD,OAAO,MAAMC,aAAa,GAAGJ,KAAK,CAACK,MAAM,CAAC;EACtCC,OAAO,EAAEH;AACb,CAAC,CAAC;AAEF,OAAO,MAAMI,WAAW,GAAGP,KAAK,CAACK,MAAM,CAAC;EACpCC,OAAO,EAAEH;AACb,CAAC,CAAC;AAEF,OAAO,MAAMK,kBAAkB,GAAG,CAACC,YAAY,EAAEC,cAAc,KAAK;EAChEC,YAAY,CAACC,OAAO,CAACX,KAAK,EAAEY,IAAI,CAACC,SAAS,CAAC;IACvCL,YAAY;IACZC;EACJ,CAAC,CAAC,CAAC;AACP,CAAC;AAED,OAAO,MAAMK,eAAe,GAAG,MAAMF,IAAI,CAACG,KAAK,CAACL,YAAY,CAACM,OAAO,CAAChB,KAAK,CAAC,IAAI,IAAI,CAAC;AAEpF,OAAO,MAAMiB,iBAAiB,GAAG,MAAM,CAAC,CAACH,eAAe,EAAE,CAACN,YAAY;AAEvE,OAAO,MAAMU,iBAAiB,GAAG,MAAMR,YAAY,CAACS,UAAU,CAACnB,KAAK,CAAC;AAErEM,WAAW,CAACc,YAAY,CAACC,OAAO,CAACC,GAAG,CAAC,MAAOC,MAAM,IAAK;EACnD,IAAIC,mBAAmB,GAAG,CAAC,CAACD,MAAM,CAACE,OAAO,CAACC,KAAK;EAChDC,OAAO,CAACC,GAAG,CAACJ,mBAAmB,CAAC;EAChC,IAAIP,iBAAiB,EAAE;IAAA;IACnB,MAAMY,WAAW,4BAAGN,MAAM,CAACE,OAAO,CAACC,KAAK,0DAApB,sBAAsBI,SAAS,CAAC,CAAC,CAAC;IACtD,IAAIC,WAAW,GAAG,IAAIC,IAAI,EAAE;IAC5B,MAAMC,YAAY,GAAGJ,WAAW,IAAI5B,UAAU,CAAC4B,WAAW,CAAC;IAC3DL,mBAAmB,GAAGS,YAAY,IAAIA,YAAY,CAACC,GAAG,GAAG,IAAI,GAAGH,WAAW,CAACI,OAAO,EAAE;EACzF;EACA,IAAI,CAACX,mBAAmB,EAAE;IACtB,MAAM;MAAEhB,YAAY;MAAEC;IAAe,CAAC,GAAGK,eAAe,EAAE;IAC1D,IAAI;MACA,MAAMsB,GAAG,GAAG,MAAMjC,aAAa,CAACkC,GAAG,CAAC,qBAAqB,EAAE;QAAE7B,YAAY;QAAEC;MAAe,CAAC,CAAC;MAC5FF,kBAAkB,CAAC6B,GAAG,CAACE,IAAI,CAAC9B,YAAY,EAAEC,cAAc,CAAC;MACzDc,MAAM,CAACE,OAAO,CAAC,OAAO,CAAC,GAAG,SAAS,GAAGW,GAAG,CAACE,IAAI,CAACC,cAAc;IACjE,CAAC,CAAC,OAAOC,GAAG,EAAE;MACVb,OAAO,CAACc,KAAK,CAACD,GAAG,CAAC;IACtB;EACJ;EACA,OAAOjB,MAAM;AACjB,CAAC,EAAGkB,KAAK,IAAK;EACV,OAAOC,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;AAChC,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}